/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NeuroVoxPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/settings/Settings.ts
var DEFAULT_SETTINGS = {
  openaiApiKey: "",
  openaiModel: "gpt-4",
  maxTokens: 500,
  generateAudioSummary: false,
  voiceChoice: "alloy",
  prompt: "Distill the essence. Capture every vital detail with utmost brevity, ensuring no meaning is lost. Crystallize the core message.",
  voiceSpeed: 1,
  saveRecording: true,
  voiceMode: "standard",
  enableVoiceGeneration: false,
  recordingFolderPath: "Recordings"
  // Add this line
};

// src/settings/SettingTab.ts
var import_obsidian = require("obsidian");
var NeuroVoxSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Enter your OpenAI API Key").addText((text) => {
      text.inputEl.type = "password";
      text.setPlaceholder("Enter API Key").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
        this.plugin.settings.openaiApiKey = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("OpenAI Model").setDesc("Select the OpenAI Model to use").addText(
      (text) => text.setPlaceholder("Enter model name").setValue(this.plugin.settings.openaiModel).onChange(async (value) => {
        this.plugin.settings.openaiModel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName(`Max Tokens (${this.plugin.settings.maxTokens})`).setDesc("Maximum number of tokens").addSlider((slider) => {
      slider.setLimits(0, 128e3, 500).setValue(this.plugin.settings.maxTokens).onChange(async (value) => {
        this.plugin.settings.maxTokens = value;
        this.display();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Prompt").setDesc("This prompt is used when generating summaries.").addTextArea((text) => {
      text.inputEl.style.width = "100%";
      text.inputEl.style.height = "64px";
      text.inputEl.style.resize = "vertical";
      text.setPlaceholder("Enter prompt").setValue(this.plugin.settings.prompt).onChange(async (value) => {
        this.plugin.settings.prompt = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Generate Audio Summary").setDesc("Enable or disable audio summary generation").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.generateAudioSummary).onChange(async (value) => {
        this.plugin.settings.generateAudioSummary = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable AI Voice Generation of Summaries").setDesc(
      "Whether to enable AI voice generation from transcription summaries"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableVoiceGeneration).onChange(async (value) => {
        this.plugin.settings.enableVoiceGeneration = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Voice Choice").setDesc("Select the voice for audio summary").addDropdown((dropdown) => {
      dropdown.addOption("alloy", "Alloy").addOption("echo", "Echo").addOption("fable", "Fable").addOption("onyx", "Onyx").addOption("nova", "Nova").addOption("shimmer", "Shimmer").setValue(this.plugin.settings.voiceChoice).onChange(async (value) => {
        this.plugin.settings.voiceChoice = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName(`Voice Speed (${this.plugin.settings.voiceSpeed})`).setDesc("Set the speed of the voice").addSlider((slider) => {
      slider.setLimits(0.25, 4, 0.25).setValue(this.plugin.settings.voiceSpeed).onChange(async (value) => {
        this.plugin.settings.voiceSpeed = value;
        this.display();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Enable HD Voice").setDesc("When enabled, use HD voice for audio summaries").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.voiceMode === "hd").onChange(async (value) => {
        this.plugin.settings.voiceMode = value ? "hd" : "standard";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Save Recording").setDesc("Enable or disable saving recordings").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.saveRecording).onChange(async (value) => {
        this.plugin.settings.saveRecording = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Recording Folder Path").setDesc(
      'Specify the folder path to save recordings relative to the vault root. For a folder in the root directory, enter its name (e.g., "Recordings"). For a nested folder, use forward slashes to indicate the path (e.g., "Audio/Recordings").'
    ).addText(
      (text) => text.setPlaceholder("Enter folder path").setValue(this.plugin.settings.recordingFolderPath).onChange(async (value) => {
        this.plugin.settings.recordingFolderPath = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/commands/SimpleCommand.ts
var import_obsidian2 = require("obsidian");
function registerSimpleCommand(plugin) {
  plugin.addCommand({
    id: "open-sample-modal-simple",
    name: "Open sample modal (simple)",
    callback: () => {
      new import_obsidian2.Notice("This is a notice!");
    }
  });
}

// src/processors/RecordBlockProcessor.ts
function registerRecordBlockProcessor(plugin) {
  plugin.registerMarkdownCodeBlockProcessor("record", (source, el, ctx) => {
    el.createEl("p", { text: "This is the record block" });
  });
}

// src/ui/FloatingButton.ts
var import_obsidian5 = require("obsidian");

// src/modals/TimerModal.ts
var import_obsidian3 = require("obsidian");

// src/utils/SvgUtils.ts
function createButtonWithSvgIcon(svgText) {
  const parser = new DOMParser();
  const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
  const svgElement = svgDoc.documentElement;
  const button = document.createElement("button");
  button.appendChild(svgElement);
  return button;
}

// src/assets/icons.ts
var icons = {
  microphone: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mic"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg>`,
  pause: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pause"><rect x="14" y="4" width="4" height="16" rx="1"/><rect x="6" y="4" width="4" height="16" rx="1"/></svg>`,
  play: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play"><polygon points="6 3 20 12 6 21 6 3"/></svg>`,
  stop: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-square"><rect width="18" height="18" x="3" y="3" rx="2"/></svg>`
};

// src/modals/TimerModal.ts
var TimerModal = class extends import_obsidian3.Modal {
  constructor(app) {
    super(app);
    this.intervalId = null;
    this.seconds = 0;
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.recordingStopped = false;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("neurovox-modal");
    this.timerEl = contentEl.createEl("div", { cls: "timer", text: "00:00" });
    const buttonGroup = contentEl.createEl("div", { cls: "button-group" });
    this.playButton = createButtonWithSvgIcon(icons.play);
    this.pauseButton = createButtonWithSvgIcon(icons.pause);
    this.stopButton = createButtonWithSvgIcon(icons.stop);
    this.playButton.addClass("neurovox-button");
    this.pauseButton.addClass("neurovox-button");
    this.stopButton.addClass("neurovox-button");
    this.playButton.style.display = "none";
    buttonGroup.appendChild(this.playButton);
    buttonGroup.appendChild(this.pauseButton);
    buttonGroup.appendChild(this.stopButton);
    this.playButton.addEventListener("click", () => this.startRecording());
    this.pauseButton.addEventListener("click", () => this.pauseRecording());
    this.stopButton.addEventListener("click", () => this.stopRecording());
    this.startRecording();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (!this.recordingStopped) {
      this.stopRecording();
    }
  }
  async startRecording() {
    this.playButton.style.display = "none";
    this.pauseButton.style.display = "flex";
    if (!this.intervalId) {
      this.intervalId = window.setInterval(() => {
        this.seconds++;
        this.updateTimerDisplay();
      }, 1e3);
    }
    if (!this.mediaRecorder) {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.mediaRecorder = new MediaRecorder(stream);
      this.mediaRecorder.ondataavailable = (event) => {
        this.audioChunks.push(event.data);
      };
      this.mediaRecorder.start();
    } else {
      this.mediaRecorder.resume();
    }
  }
  pauseRecording() {
    if (this.mediaRecorder) {
      this.mediaRecorder.pause();
    }
    if (this.intervalId) {
      window.clearInterval(this.intervalId);
      this.intervalId = null;
    }
    this.playButton.style.display = "flex";
    this.pauseButton.style.display = "none";
  }
  stopRecording() {
    if (this.recordingStopped)
      return;
    this.recordingStopped = true;
    if (this.mediaRecorder) {
      this.mediaRecorder.onstop = () => {
        const audioBlob = new Blob(this.audioChunks, { type: "audio/mp3" });
        this.audioChunks = [];
        if (this.onStop) {
          this.onStop(audioBlob);
        }
        this.close();
      };
      this.mediaRecorder.stop();
      this.mediaRecorder.stream.getTracks().forEach((track) => track.stop());
      this.mediaRecorder = null;
    }
    if (this.intervalId) {
      window.clearInterval(this.intervalId);
      this.intervalId = null;
    }
    this.seconds = 0;
    this.updateTimerDisplay();
    this.playButton.style.display = "flex";
    this.pauseButton.style.display = "none";
  }
  updateTimerDisplay() {
    const minutes = Math.floor(this.seconds / 60).toString().padStart(2, "0");
    const seconds = (this.seconds % 60).toString().padStart(2, "0");
    this.timerEl.textContent = `${minutes}:${seconds}`;
  }
};

// src/utils/FileUtils.ts
var import_obsidian4 = require("obsidian");
async function saveAudioFile(app, audioBlob, fileName, settings) {
  const fileManager = app.fileManager;
  let filePath = await fileManager.getAvailablePathForAttachment(fileName);
  const folderPath = settings.recordingFolderPath;
  filePath = `${folderPath}/${filePath}`;
  const folder = app.vault.getAbstractFileByPath(folderPath);
  if (!folder) {
    console.log(`Folder ${folderPath} does not exist. Creating...`);
    await app.vault.createFolder(folderPath);
  } else if (!(folder instanceof import_obsidian4.TFolder)) {
    throw new Error(`${folderPath} is not a folder`);
  }
  const arrayBuffer = await audioBlob.arrayBuffer();
  const uint8Array = new Uint8Array(arrayBuffer);
  const existingFile = app.vault.getAbstractFileByPath(filePath);
  if (existingFile) {
    await app.vault.delete(existingFile);
  }
  const file = await app.vault.createBinary(filePath, uint8Array);
  console.log(`Saved recording as ${file.path}`);
  return file;
}

// src/ui/FloatingButton.ts
var FloatingButton = class {
  constructor(plugin, settings) {
    this.plugin = plugin;
    this.settings = settings;
    this.createButton();
    this.registerEvents();
  }
  createButton() {
    this.buttonEl = createButtonWithSvgIcon(icons.microphone);
    this.buttonEl.classList.add("neurovox-button", "floating");
    this.buttonEl.style.display = "none";
    this.buttonEl.addEventListener("click", () => {
      const modal = new TimerModal(this.plugin.app);
      modal.open();
      modal.onStop = async (audioBlob) => {
        const fileName = `recording-${Date.now()}.mp3`;
        const file = await saveAudioFile(this.plugin.app, audioBlob, fileName, this.settings);
        new import_obsidian5.Notice(`Saved recording as ${file.path}`);
      };
    });
    document.body.appendChild(this.buttonEl);
  }
  registerEvents() {
    this.plugin.registerEvent(this.plugin.app.workspace.on("active-leaf-change", this.toggleButtonVisibility.bind(this)));
  }
  toggleButtonVisibility(leaf) {
    const currentButtonParent = this.buttonEl.parentElement;
    if (currentButtonParent) {
      currentButtonParent.removeChild(this.buttonEl);
    }
    if (leaf && leaf.view && leaf.view.getViewType() === "markdown") {
      const viewContent = leaf.view.containerEl.querySelector(".view-content");
      if (viewContent) {
        viewContent.appendChild(this.buttonEl);
        this.buttonEl.style.display = "flex";
      }
    } else {
      this.buttonEl.style.display = "none";
    }
  }
};

// src/main.ts
var NeuroVoxPlugin = class extends import_obsidian6.Plugin {
  async onload() {
    console.log("NeuroVox Plugin Loaded");
    await this.loadSettings();
    registerSimpleCommand(this);
    registerRecordBlockProcessor(this);
    this.floatingButton = new FloatingButton(this, this.settings);
    this.addSettingTab(new NeuroVoxSettingTab(this.app, this));
  }
  onunload() {
    console.log("NeuroVox Plugin Unloaded");
    if (this.floatingButton && this.floatingButton.buttonEl.parentElement) {
      this.floatingButton.buttonEl.parentElement.removeChild(this.floatingButton.buttonEl);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
